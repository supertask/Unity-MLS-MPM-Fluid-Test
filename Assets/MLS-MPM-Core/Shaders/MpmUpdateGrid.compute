#pragma kernel UpdateGrid

#include "./MpmStruct.hlsl"
#include "./Constant.hlsl"
#include "./Grid.hlsl"
#include "./SVD.hlsl"

#define THREAD_1D 256

float _DeltaTime;

#if defined(__LockGathering) || defined(__LockFreeGathering)
    RWStructuredBuffer<LockMpmCell> _GridBuffer;
#else
    RWStructuredBuffer<MpmCell> _GridBuffer;
#endif

[numthreads(THREAD_1D,1,1)]
void UpdateGrid(uint3 DTid : SV_DispatchThreadID)
{
	const uint idx = DTid.x;

	#if defined(__LockGathering) || defined(__LockFreeGathering)
		LockMpmCell cell = _GridBuffer[idx];
	#else
		MpmCell cell = _GridBuffer[idx];
	#endif

	uint3 cidx = CellIndex1DTo3D(idx);

    if (cell.mass <= 0)
    {
		cell.force = 0;
        cell.mass = 0;
        cell.mass_x_velocity = 0;
        cell.velocity = 0;
    }
    else
    {

        #if defined(__LockGathering) || defined(__LockFreeGathering)
            //float mass = ((float)cell.mass) / FLOAT_TO_INT_DIGIT;
            //float3 mass_x_velocity = ((float)cell.mass_x_velocity) / FLOAT_TO_INT_DIGIT;
            float mass = ((float)cell.mass) * INT_TO_FLOAT_DIGIT;
            float3 mass_x_velocity = ((float)cell.mass_x_velocity) * INT_TO_FLOAT_DIGIT;
        #else
            float mass = cell.mass;
            float3 mass_x_velocity = cell.mass_x_velocity;
        #endif

        cell.velocity = mass_x_velocity / mass;

        float3 g = float3(0.0f,-9.8f, 0.0f);
        cell.velocity += _DeltaTime * (cell.force / mass + g);
        if (cidx.x < 2 || cidx.x >= _GridResolutionWidth - 2) cell.velocity.x = 0;
        if (cidx.y < 2 || cidx.y >= _GridResolutionHeight - 2) cell.velocity.y = 0;
        if (cidx.z < 2 || cidx.z >= _GridResolutionDepth - 2) cell.velocity.z = 0;
    }

    _GridBuffer[idx] = cell;
}
