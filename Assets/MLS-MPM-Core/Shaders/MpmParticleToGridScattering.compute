#pragma kernel ParticleToGridScatteringOpt

//Assets/MLS-MPM-Core/Shaders
#include "MpmStruct.hlsl"
#include "./Constant.hlsl"
#include "./Grid.hlsl"
#include "./SVD.hlsl"

#define THREAD_1D 256

float _DeltaTime;
int _NumOfParticles;

// Parameters of hyper elastic material.
float _HyperElasticHardening;
float _HyperElasticMu;
float _HyperElasticLambda;

RWStructuredBuffer<MpmParticle> _ParticlesBufferRead;
//RWStructuredBuffer<MpmCell> _GridBuffer;
RWStructuredBuffer<LockMpmCell> _GridBuffer;

[numthreads(THREAD_1D,1,1)]
void ParticleToGridScatteringOpt(uint3 DTid : SV_DispatchThreadID)
{
    const uint particleId = DTid.x;
	MpmParticle particle = _ParticlesBufferRead[particleId];
	if (particle.type == TYPE__INACTIVE) return;

	float3x3 F = particle.Fe;
	float3x3 R = 0;
	float3x3 U ;
	float3 d;
	float3x3 V;

	float volume = particle.volume;
	float3x3 Dinv = InvApicD();
	
	GetSVD3D(F, U, d, V);
	R = mul(U, transpose(V));

	float e = 1;
	float mu = _HyperElasticMu;
	float lambda = _HyperElasticLambda;

	float j = determinant(F);
	//if(particle.type == 2)
	//{
		e = exp(_HyperElasticHardening * (1 - particle.Jp));
	//}
	// else
	// if(particle.type == 3)
	// {
	// 	mu = 0;
	// 	j = particle.Jp;
	// }

	float mup = mu * e;
	float lambdap = lambda * e;
	float3x3 P = mul((2 * mup * (F - R)), transpose(F)) + lambdap * (j - 1) * j ;

	//if(particle.type == 3)
	//{
	//	float s = particle.Jp -1;
	//	P = float3x3(s,0,0,0,s,0,0,0,s) * mu * 10;
	//}
	float3x3 stress = -(_DeltaTime * volume) * mul(Dinv , P);
	float3x3 apic = stress + particle.mass * particle.C;

	// j = clamp(j, 0.6f,20.0f);
	// float3x3 FinvT = transpose(inverse(F));
	// float3x3 P = (2.0f * mup * (F - R)) + lambdap * (j - 1.0f) * j * FinvT;
	// float3x3 stress = 1.0f / j * mul(P, transpose(F));

	int3 centerCellIndex3D = ParticlePositionToCellIndex3D(particle.position);

	for (int gx = -1; gx <= 1; ++gx)
	{
		for (int gy = -1; gy <= 1; ++gy)
		{
			for(int gz = -1; gz <=1; ++gz)
			{
				int3 cellIndex3D = centerCellIndex3D + int3(gx,gy,gz);
				uint cellIndex = CellIndex3DTo1D(cellIndex3D);

				if (InGrid(cellIndex))
				{
					float3 gridPositionWS = CellIndex3DToPositionWS(cellIndex);
					float weight = GetWeight(particle.position, int3(gx,gy,gz));

					//ここでロックする
					LockMpmCell cell = _GridBuffer[cellIndex];
					cell.mass += weight * particle.mass;
					cell.mass_x_velocity += weight * (particle.mass * particle.velocity
						+ mul(apic, (gridPositionWS - particle.position)));
					_GridBuffer[cellIndex] = cell;
				}
			}
		}
	}

}
